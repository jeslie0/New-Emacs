#!/usr/bin/env -S emacs --script
;;; -*- lexical-binding: t -*-
;; The purpose of this file is two fold. Firstly, it looks in the
;; "../modules" folder and generates an alist of modules to their
;; path. Secondly, it looks in the users "../modules.el" file and
;; concatenates the users modules into the init.el file. This will
;; also inject the alist as a variable into the user's init file, so
;; they can see what modules are available for them to use.


;;; Code:

(defun f-expand (path &optional dir)
  "Expand PATH relative to DIR (or `default-directory').
PATH and DIR can be either a directory names or directory file
names.  Return a directory name if PATH is a directory name, and
a directory file name otherwise.  File name handlers are
ignored."
  (let (file-name-handler-alist)
    (expand-file-name path dir)))

(defun f-same-p (path-a path-b)
  "Return t if PATH-A and PATH-B are references to same file."
  (equal
   (file-truename (directory-file-name (f-expand path-a)))
   (file-truename (directory-file-name (f-expand path-b)))))

(defun f-relative-p (path)
  "Return t if PATH is relative, false otherwise."
  (not (file-name-absolute-p path)))

(defun f-dirname (path)
  "Return the parent directory to PATH."
  (let ((parent (file-name-directory
                 (directory-file-name (f-expand path default-directory)))))
    (unless (f-same-p path parent)
      (if (f-relative-p path)
          (file-relative-name parent)
        (directory-file-name parent)))))

(defun f-this-file ()
  "Return path to this file."
  (cond
   (load-in-progress load-file-name)
   ((and (boundp 'byte-compile-current-file) byte-compile-current-file)
    byte-compile-current-file)
   (:else (buffer-file-name))))



(defun file-name-list-to-string (file-list)
  "Given a FILE-LIST, take each file and concatenate them all together, in order."
  (let ((lexical-binding-string ";; -*- lexical-binding: t -*- \n\n")
        (modules-alist-string (format "(defvar modules-alist '%s \"Alist of module names and their paths\")\n\n" modules-alist) )
        (user-modules-string (format "(defvar user-modules '%s \"%s\")\n\n" user-modules (format "List of user modules, defined in %smodules.el" user-emacs-directory)))
        (user-config-string "\n\n(if (file-exists-p (concat user-emacs-directory \"config.el\"))\n(load-file (concat user-emacs-directory \"config.el\")))\n\n")
        (compile-modules-string "(defun compile-modules () \"Build the init.el file from the modules.el file.\" (interactive) (shell-command (concat user-emacs-directory \"bin/compileModules\")))\n\n"))
    (with-temp-file (concat user-emacs-directory "init.el")
      (insert lexical-binding-string)
      (insert modules-alist-string)
      (insert user-modules-string)
      (insert compile-modules-string)
      (goto-char (point-max))
      (mapc #'(lambda (file)
                (insert-file-contents (expand-file-name file))
                (goto-char (point-max)))
            file-list)
      (insert user-config-string))))


(defun f-filename (path)
  "Return the name of PATH."
  (file-name-nondirectory (directory-file-name path)))

;;; Script:


(setq modules-alist
  (let ((module-paths (directory-files-recursively (concat user-emacs-directory "modules/") "")))
    (mapcar
     (lambda (path) `(,(intern (file-name-sans-extension (f-filename path))) . ,(format "%s" path)))
     module-paths)))


(load-file (concat user-emacs-directory "modules.el"))
(file-name-list-to-string (mapcar (lambda (key) (alist-get key modules-alist)) user-modules))
(message (format "Generated %sinit.el" user-emacs-directory))


;; Local Variables:
;; mode: emacs-lisp
;; End:
